// Cоздайте класс `EventEmitter` для управления событиями. У этого класса должны быть следующие методы:
// - `.on(event, callback)` - добавить обработчик события
// - `.off(event, callback)` - удалить обработчик события
// - `.once(event, callback)` - добавить обработчик события, который сработает единожды
// - `.emit(event, [...arg])` - вызвать все обработчики события event, можно передать аргументы
// Расширьте `EventEmitter` классом `BroadcastEventEmitter` так, чтобы была возможность вызвать все обработчики всех событий:
// - `emit("*", [...arg])` - вызвать все обработчики событий, можно передать аргументы

// Event Emitter можно перевести как “транслятор” событий.

// Представьте себе такую ситуацию: происходит какое-то событие, например пользователь кликнул на кнопку, на которое должны отреагировать разные участки программы. 
// Чтобы проще организовать такую логику, используют шаблон Event Emitter, который можно реализовать разными способами. 
// Основная идея в том, чтобы грамотно создать основу для управления событиями и реализовать возможность любым элементам “подписаться” на него (и быть в курсе происходящего).



// Объявляем тип функции Callback, которая принимает любое количество аргументов типа T и ничего не возвращает (void).
type Callback<T = unknown> = (...args: T[]) => void;

// Создаем класс EventEmitter, который будет управлять событиями и их обработчиками.
  // Объявляем свойство класса, которое хранит все зарегистрированные события и их обработчики.
class EventEmitter {
  events: { [eventName: string]: Callback[] } = {};

  // Метод on - добавляет обработчик события. Принимает 2 аргумента: имя события и функцию обратного вызова
  on<T>(eventName: string, callback: Callback<T>) {
    // Проверяем, существует ли уже массив обработчиков для события eventName в объекте this.events (где хранятся все события и их обработчики)
    if (!this.events[eventName]) {
      // Если массив обработчиков для события eventName не существует, создаем его и инициализируем пустым массивом [].
      this.events[eventName] = [];
    }
    // Добавляет callback в массив обработчиков для события eventName.
    this.events[eventName].push(callback as Callback);
  }
 
  // Метод off - удаляет callback из массива обработчиков. Принимает 2 аргумента: имя события и функцию обратного вызова
  off<T>(eventName: string, callback: Callback<T>) {
    // Проверяем, существует ли событие eventName в хранилище this.events.Если событие не зарегистрировано, метод завершает работу.
    if (this.events[eventName]) {
      // Если событие eventName существует, обновляем массив его обработчиков: Используем метод filter, чтобы создать новый массив, исключив из него callback.
      this.events[eventName] = this.events[eventName].filter(
      // Для каждого обработчика (eventCallback) в массиве this.events[eventName] проверяем, не равен ли он callback.
      (eventCallback) => callback !== eventCallback);
    }
  }

  // Метод once для подписки на одноразовое событие eventName. Обработчик автоматически отписывается после первого вызова.
  once<T>(eventName: string, callback: Callback<T>) {
    // Проверяем, существует ли массив обработчиков для события eventName.
      // Если массив не существует (например, событие eventName вызывается впервые), создаем пустой массив для хранения обработчиков.
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    // Создаем новую функцию-обертку onceEvent, которая будет вызывать оригинальный callback и затем отписывать себя от события.
    const onceEvent = (...args: unknown[]) => {
      // Вызываем оригинальный callback, передавая ему аргументы args. Приводим args к типу T[].
      callback(...(args as T[]));
      // После вызова callback отписываем onceEvent от события eventName с помощью метода off.
      this.off(eventName, onceEvent);
    };
    // Добавляем onceEvent в массив обработчиков для события eventName.
    this.events[eventName].push(onceEvent as Callback);
    // Возвращаем this (текущий объект EventEmitter)
    return this;
  }

  // Объявляем метод emit, который принимает два параметра: eventName и аргументы, которые будут переданы в обработчики события.
  emit<T>(eventName: string, ...args: T[]) {
    // Получаем массив обработчиков (функций), связанных с событием eventName, из хранилища this.events.
    const event = this.events[eventName];
    // Проверяем, существует ли массив обработчиков для события eventName.
    if (event) {
      // Если событие существует, проходим по всем его обработчикам с помощью метода forEach. Для каждого callback вызываем его, передавая аргументы ...args
      event.forEach(callback => callback(...args));
    }
  }
}

// Объявляем класс BroadcastEventEmitter, который наследует от EventEmitter.
class BroadcastEventEmitter extends EventEmitter {
  // Переопределяем метод emit из родительского класса. Он принимает имя события и аргументы, которые будут переданы в обработчики события.
  emit<T>(event: string, ...args: T[]) {
    // Проверяем, является ли событие event специальным событием "*".
    if (event !== '*') {
      // Если событие не "*", вызываем метод emit родительского класса (EventEmitter). Вызываются только обработчики, подписанные на конкретное событие event.
      super.emit(event, ...args);
    // Если событие — это "*", переходим к блоку рассылки.
    } else {
      // Возвращаем массив строк, которые зарегистрированы в объекте this.events. Проходим по каждому элементу массива (каждому имени события e).
      Object.keys(this.events).forEach(
        // Вызываем метод emit из родительского класса. Передаем в emit два аргумента: имя текущего события и аргументы, которые нужно передать в обработчики событий.
        e => super.emit(e, ...args));
    }
  }
}

export { BroadcastEventEmitter, EventEmitter };