// Реализуйте функцию merge, которая будет принимать неограниченное количество объектов в качестве аргументов и возвращать новый объект, 
// который должен содержать все поля со всех объектов.
// Если ключи в объектах повторяются, то каждый последующий объект при совпадении ключей должен иметь больший приоритет над предыдущим. 
// Порядок полей в результирующем объекте не важен.

const merge = <T extends object>(...objects: T[]): T => {
  let sum: T = {} as T;
  for (let obj of objects) {
    sum = { ...sum, ...obj };
  }
  return sum;
};

export default merge;

// Объявляем стрелочную функцию merge с дженериком T (только тип object). Использование дженерика позволяет TypeScript более корректно выводить типы.
// Функция принимает неограниченное количество аргументов objects (через rest оператор) с указанием что objects - массив элементов типа T
// Указываем сразу тип возвращаемого значения - T.

  // Объявляем переменную sum, для того чтобы хранить результат объединения объектов.
  // Устанавливаем значение переменной как пустой объект {} + используем as T, чтобы TypeScript знал, что пустой объект имеет тип T

  // Проходим по каждому объекту из массива objects с помощью цикла for...of.
    // Объединяем текущий результат sum с текущим объектом obj. Создаем новый объект, который содержит все свойства из sum и obj (используем spread оператор).
    // Если свойства повторяются, значения берутся из obj (последний объект "перезаписывает" значения по правилу spread оператора т.к. он обрабатывает объекты последовательно).

    // Возвращаем итоговый объединенный объект.